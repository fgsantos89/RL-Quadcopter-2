{
    "batch_size": 64,
    "best_score": -4.319158100246991,
    "buffer_size": 100000,
    "gamma": 0.95,
    "noise": {
        "exploration_mu": 0.0,
        "exploration_sigma": 0.3,
        "exploration_theta": 0.15
    },
    "reward_function": "    def get_reward(self):\n        \"\"\"Uses current pose of sim to return reward.\"\"\"\n        # 1 - .3 * (abs(self.sim.pose[:3] - self.target_pos)).sum()\n\n        # recompensa pela velocidade do eixo para a decolagem\n        reward = self.sim.v[2]\n\n        # recompensa constante para se manter dentro do quadrante v?ido\n        reward += 10\n\n        # penalizar pela instabilidade dos angulos\n        reward -= abs(self.sim.pose[3:]).sum()\n\n        # penalizar pela distancia do eixos x, y, z do target\n        reward -= np.sum(abs(self.sim.pose[:3] - self.target_pos[:3]))\n\n        # penalizar pela velocidades dos outros eixos\n        reward -= np.sum(abs(self.sim.v[:2]))\n\n        return reward\n",
    "tau": 0.01
}