{
    "batch_size": 64,
    "best_score": 157.8632385716167,
    "buffer_size": 100000,
    "gamma": 0.95,
    "noise": {
        "exploration_mu": 0.0,
        "exploration_sigma": 0.3,
        "exploration_theta": 0.15
    },
    "reward_function": "    def get_reward(self):\n        \"\"\"Uses current pose of sim to return reward.\"\"\"\n        # 1 - .3 * (abs(self.sim.pose[:3] - self.target_pos)).sum()\n\n        # tenho que pensar numa reward que seja mais gen\u00e9rica\n        # n\u00e3o somente para decolagem\n\n        # recompensa constante para se manter dentro do quadrante v\u00e1lido\n        reward = 3.\n\n        # penalizar pela posicao\n        # penalizar pela distancia do eixos x, y, z do target\n        # distancia maxima \u00e9 300 m em cada dire\u00e7\u00e3o\n        reward -= .4 * (abs(self.sim.pose[:3] - self.target_pos)).sum()\n\n        # recompensa pela velocidade do eixo\n        # (-15, 15) m/s\n        reward += 0.05 * abs(self.sim.v).sum()\n\n        # penalizar pela instabilidade dos angulos\n        # (0, 6)\n        reward -= 0.05 * abs(self.sim.pose).sum()\n\n        # punir um pouco pela velocidade angular\n        reward -= 0.2 * abs(self.sim.angular_v).sum()\n\n        return reward\n",
    "tau": 0.01
}